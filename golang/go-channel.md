## 并发与并行

* 并行
    通过使用多处理器提高运行速度的能力。并发的程序可以是并行

* 并发
    程序在一个或者多个处理器上使用多个线程来执行任务，但同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。

## go协程(goroutines)

golang 中应用程序并发处理的部分被称作goroutines——协程

* Go协程与协程区别

    1. Go协程意味着并行（或者可以以并行的方式部署），协程(coroutines)一般来不是这样的
    2. Go协程通过通道来通信；协程(coroutines)通过让出和恢复操作来通信


## 通道阻塞

默认情况下，通信是同步且无缓冲的：在接受者接收数据之前，发送不会结束。必须要一个接收者准备接收通道的数据，
发送者才可以直接把数据发送给接收者。

* 对同一个通道，发送操作(协程或者函数中的),在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其它的数据。

* 对同一个通道，接收操作是阻塞的，直到发送者可用。如果通道中没有数据，接收者就阻塞

```
func main() {
    i := make(chan int)
    go pump(i)

    fmt.Println(<-i)
}

func pump(ch chan int) {
    for i := 0; ; i++ {
        ch <- i
    }
}
```

> 一个协程无限循环给通道发送数据，不过没有接收者，只输出了一个0

* 无缓冲通道

```
ch := make(chan int)
```

##同步通道——使用带缓冲的通道

一个无缓冲的通道一般只能包含1个元素，有时显得很局限。可以通过make命令设置容量，如：
```
ch := make(chan int, 100)
```
即为通道设置了一100个元素的容量.

> 当通道的长度大于０时通道是异步的，缓冲满载或者变空之前不会阻塞，元素会按照发送的顺序被接收。如果为０或者未设置，
则通信仅在收发双方准备好的情况下才可以发送成功






