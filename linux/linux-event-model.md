##

服务器程序通常需要处理三类事件:I/O事件\ 信号及定时事件.


## Reactor 模式

Reactor 要求主线程只负责监听文件描述上是否有事件发生,有的话就立即将该事件通知工作线程.除此之外
主线程不做任何其他实质的工作．读写数据，接受新的连接，以及处理客户请求均在工作线程中完成．

* 使用同步I/O模型(以epoll_wait为例)实现的Reactor 模式工作流程

1. 主线程往epoll内核事件表中注册socket上的读就绪事件

2. 主线程调用epoll_wait等待socket上有数据可读

3. 当socket上有数据可读时，　epoll_wait通知主线程．主线程则将socket可读事件放入请求队列

4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表
中注册该socket上的写就绪事件

5. 主线程调用epoll_wait等待socket可写

6. 当socket可写时，epoll_wait通知主．主线程将socket可写事件放入请求队列.

7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果．


## Proactor 模式

与Reactor模式不同，　Proactor模式将所有i/o操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑．

* 使用异步I/O模型的工作流程：

1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时
如何通知应用程序

2. 主线程继续处理其他逻辑

3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用．

4. 应用程序预告定义好的信号处理函数选择一个工作线程来处理客户请求．工作线程处理完客户请求后，调用aio_write
函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序

5.主线程继续处理其他逻辑

6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕

7. 应用程序预告定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket